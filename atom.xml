<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>async&#39;s Blog</title>
  
  <subtitle>古壁生凝尘，羁魂梦中语。</subtitle>
  <link href="https://async0826.me/atom.xml" rel="self"/>
  
  <link href="https://async0826.me/"/>
  <updated>2023-03-12T01:12:11.397Z</updated>
  <id>https://async0826.me/</id>
  
  <author>
    <name>async</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单链表的一些基础操作</title>
    <link href="https://async0826.me/2023/03/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>https://async0826.me/2023/03/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2023-03-06T07:14:25.000Z</published>
    <updated>2023-03-12T01:12:11.397Z</updated>
    
    <content type="html"><![CDATA[<p>        初学数据结构，首先接触的就是线性表，而最基本的线性表又可以通过单链表来进行实现。</p><p>        本文的单链表使用了头节点的方式。（即第一个结点的数据域为空，指针域指向首节点）。</p><p>        询问了ChatGPT后，我所得到的关于单链表的基本操作有以下几点：</p><ol><li><p>创建一个空链表。</p></li><li><p>按值插入节点：在链表中插入一个新节点，该节点包含一个给定的值。</p></li><li><p>按位置插入节点：在链表中插入一个新节点，该节点插入到指定的位置。</p></li><li><p>删除节点：删除链表中的一个节点，可以删除链表的头部、尾部或中间的一个节点。</p></li><li><p>修改节点：修改链表中一个节点的值。</p></li><li><p>查找节点：在链表中查找一个节点，可以根据节点的值或索引来查找。</p></li><li><p>获取节点：获取链表中指定位置的节点。</p></li><li><p>获取链表长度：获取链表中节点的个数。</p></li><li><p>清空链表：清空链表中的所有节点，使链表变为空链表。</p></li><li><p>判断链表是否为空。</p></li><li><p>遍历链表：遍历链表中的所有节点，可以按照顺序输出链表中的每个节点的值。</p></li><li><p>链表反转：将链表翻转，即原来的最后一个节点变成第一个节点，原来的第一个节点变成最后一个节点。</p></li><li><p>链表排序：将链表按照指定的规则进行排序。</p></li><li><p>合并链表：将两个链表合并成一个新的链表。</p></li><li><p>判断链表是否有环。</p></li></ol><p>接下来我们通过代码具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitLinkList</span><span class="params">(Nodeptr *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    *L = (Nodeptr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        首先是初始化链表，此处笔者犯了一个很基本的错误，在传参部分最初传入了Nodeptr L而不是Nodeptr *L，可能大多数的初学者在自我尝试时也会犯这样的错误。直接传入节点的指针是无法对指针本身的值做出变化的，这是因为函数是不能改变传入的参数的值的，要想改变值，就要使用指针。初始化链表的目的是为了使用malloc函数在内存中申请一个节点的空间，并且将该节点的地址传入到头节点L中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeadCreate</span><span class="params">(Node *L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node *new = (Nodeptr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new-&gt;data = data;</span><br><span class="line">    new-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        而后是使用头插法插入节点，在这里笔者学到的是为了保证安全性，最好每次传入一个节点的指针时都应该检查一下这个指针会不会指向NULL，以此来规避可能出现的内存访问错误。头插法的原理主要就是先申请一个空间，而后把你所需要的值传入。最后把新节点的指针域指向原头节点的指针域，而后把原头结点的指针域改为指向新节点。这样你每次新创建的值就会在头节点之后啦（不然你以为为什么会叫做头插法）。</p><p>        而尾插法与头插法其实算是比较类似的，只不过要先找到最后的那个节点。可以通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    L = L-&gt;next;</span><br></pre></td></tr></table></figure><p>这种方式来寻找，然后把新节点的指针域指向NULL，把原尾节点的指针指向新节点。</p><p>        而如果想要在任意位置插入节点进行查找，则可以通过设定具体的循环此处来进行。此处直接上代码，不再赘言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(Nodeptr L, <span class="type">int</span> locate, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr new = (Nodeptr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new-&gt;data = data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locate - <span class="number">1</span>; i++)</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    new-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        接下来是删除节点。想要删除一个节点，需要先找到被删除节点的前一个节点，将被删除节点的前一个结点指向删除结点的下一个节点，而后使用free()函数释放掉被删除节点的内存以此来达到删除的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteNode</span><span class="params">(Nodeptr L, <span class="type">int</span> locate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr pre;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locate; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = L-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        想要改变节点的值，这里有两种方式，第一种是通过数据域的数值来查找，第二种是通过节点的位置来查找。不过其实大同小异。要改变节点的值，首先要找到这个要被改变的节点，第一种直接通过对比数据域来查找就好，不过只能找到第一个与查找数据域相同的；而第二种通过位置来查找的则与上文提到的任意位置插入的方案一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过数据来查找</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChangeNode_num</span><span class="params">(Nodeptr L, <span class="type">int</span> change, <span class="type">int</span> before)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr P;</span><br><span class="line">    <span class="keyword">for</span> (P = L; P-&gt;data != before; P = P-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    P-&gt;data = change;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过位置来查找</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChangeNode_locate</span><span class="params">(Nodeptr L, <span class="type">int</span> locate, <span class="type">int</span> change)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locate; i++)</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    L-&gt;data = change;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        获取节点其实就是在查找节点的基础上返回节点的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Nodeptr <span class="title function_">GetNode_num</span><span class="params">(Nodeptr L, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Nodeptr P;</span><br><span class="line">    <span class="keyword">for</span> (P = L; P-&gt;data != num; P = P-&gt;next);</span><br><span class="line">        retur</span><br><span class="line">n P;</span><br><span class="line">&#125;<span class="comment">//tips：此处的问题还是只能够返回多个相同值中第一个值的结点。</span></span><br><span class="line"></span><br><span class="line">Nodeptr <span class="title function_">GetNode_locate</span><span class="params">(Nodeptr L, <span class="type">int</span> locate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locate; i++)</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取结点的长度也很简单，只需要通过遍历整个链表，然后每次经过一个节点使用一个变量加上一就好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetLength</span><span class="params">(Nodeptr L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; L-&gt;next != <span class="literal">NULL</span>; i++, L = L-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空链表则是在遍历整个链表的基础上使用之前所写的DeleteNode()函数，但此处需要注意的是需要用一个辅助指针来进行节点的保存，否则无法达到删除整个链表的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr P;</span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P = L-&gt;next;</span><br><span class="line">        L-&gt;next = P-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(P);</span><br><span class="line">    &#125;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断链表是否为空链表，只需要看头节点是否为空即可，若头节点的指针为空指针，说明这个链表中什么都没有。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isEmptyList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要把链表逆序，此处提出两种方案。第一种是使用三指针法：</p><p>    1.初始化三个指针pre、cur、next，pre指向NULL，cur指向第一个节点，next指向cur的下一个节点。</p><p>    2.将cur节点的next指向pre节点，即将cur的后继节点指向前驱节点，实现逆序。</p><p>    3.将pre指针向后移动一个位置，指向cur节点，cur指针向后移动一个位置，指向next节点。</p><p>    4.重复第二步和第三步，直到cur指针指向NULL，此时链表已经逆序完成。</p><p>    5.最后将链表头节点指向逆序后的第一个节点pre即可。</p><p>整个过程中，每次都将cur节点的后继节点指向前驱节点，从而实现了链表的逆序。</p><p>以下是整个过程的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ReverseList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr pre = <span class="literal">NULL</span>;</span><br><span class="line">    Nodeptr cur = L-&gt;next;</span><br><span class="line">    Nodeptr next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍另外一种方式：可以先把链表拆分为两个链表，一个只含有头节点，一个含有所有数据，然后使用头插法把含有所有数据的链表的节点逐个插入到只含有头结点的链表中去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ReverseList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的只包含头节点的链表</span></span><br><span class="line">    Nodeptr newL = (Nodeptr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newL-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原链表的数据节点一个一个地插入新链表的头节点之后</span></span><br><span class="line">    Nodeptr cur = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Nodeptr next = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点插入新链表的头节点之后</span></span><br><span class="line">        cur-&gt;next = newL-&gt;next;</span><br><span class="line">        newL-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原链表的头节点指向新链表的头节点</span></span><br><span class="line">    L-&gt;next = newL-&gt;next;</span><br></pre></td></tr></table></figure><p>如果想要对链表进行排序，此处可以使用冒泡排序，对每个结点中的数据进行排序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RankList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr p = L-&gt;next;</span><br><span class="line">    Nodeptr q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data &gt; q-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = p-&gt;data;</span><br><span class="line">                p-&gt;data = q-&gt;data;</span><br><span class="line">                q-&gt;data = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断链表是否有环，可以使用快慢指针的方式：快指针始终会比慢指针快，如果有环则两者就进入了一个环中，读者可以想象一下，在运动场上跑步时，不限制时间，跑的快的人总会有一次与慢的人相遇，在这里也是一样。快指针在环中不限时间，总会有与慢指针相遇的时候，所以可以把这个作为判断条件来判断链表中是否有环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">is_ring_list</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr p = L-&gt;next;</span><br><span class="line">    Nodeptr q = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p == q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是链表的一些基本操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;        初学数据结构，首先接触的就是线性表，而最基本的线性表又可以通过单链表来进行实现。&lt;/p&gt;
&lt;p&gt;        本文的单链表使用了头节点的方式。（即第一个结点的数据域为空，指针域指向首节点）。&lt;/p&gt;
&lt;p&gt;        询问了ChatGPT后，我所得到的</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://async0826.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>不愿意安于现状的</title>
    <link href="https://async0826.me/2023/03/05/%E4%B8%8D%E6%84%BF%E6%84%8F%E5%AE%89%E4%BA%8E%E7%8E%B0%E7%8A%B6%E7%9A%84/"/>
    <id>https://async0826.me/2023/03/05/%E4%B8%8D%E6%84%BF%E6%84%8F%E5%AE%89%E4%BA%8E%E7%8E%B0%E7%8A%B6%E7%9A%84/</id>
    <published>2023-03-05T06:46:11.000Z</published>
    <updated>2023-03-05T07:04:45.708Z</updated>
    
    <content type="html"><![CDATA[<p>    上课的第一周，算是超级忙碌的一周。</p><p>    上下午基本上都有课，有时候晚上也有课，十点下完课后跟随人潮涌回宿舍，有一种奇怪的感觉。</p><p>    其实一个人走也会有这种感觉吧，发自内心深处的孤独。自己似乎还是不太适合喜欢别人。好像这句话自己已经对自己说了很多遍了。倒不是喜欢别人别人会怎么样，只是自己太容易患得患失，而且还有一点点讨好型人格在身上的。</p><p>    所以还是好好一个人走吧，就算是一个人出去看看成都。</p><p>    突然想到上个学期回家前两天，同一个宿舍的同学在十点过后拿起书包走出宿舍门，我惶恐地问他：这个点你出去要干嘛。但他只是说：我想去看看成都。我也想去看看成都。疫情以来确实失去了太多。高三过后犹如囚笼的暑假，并没有如自己高考前所想的那样美好：能够与同学一起去一场毕业旅行，和喜欢的人一起走向自己喜欢的大学。</p><p>    刚刚起床刷朋友圈，看到高中的一个在华东师范大学的同学去了上海交大，有点难受的吧。毕竟算是我喜欢了三年的大学。结果自己也没有如意，高考的那两天算是前十九年里过的最失败最恍惚的两天了吧。但怎么可能会有完美的一生。今后也还是会有很多不如意的吧。但也只能在当下尽量别让以后的自己像现在这样了。</p><p>    还没到时间怀念从前。</p><p>    虽然这次考试确实真的考得很烂，但才六分之一呢。凭什么因为一个学期的落后就否定掉自己。也希望不是在自我洗脑吧。</p><p>    也别再想，如果当初自己选择的不是抛弃，而是和她一起努力，结果会不会不一样了吧。毕竟好像你已经不想再花这样的时间与精力去重新认识一个人了。可能她也不想吧，那个我十八岁偷偷送我生日蛋糕的女孩。</p><p>    大概灵魂深处还是渴望得到陪伴，得到理解吧。但好像永远都不会有这样的异性了。</p><p>    所以还是把精力更多地花在自己身上吧。不要安于现状，有自己的秘密计划，努力争取自己的幸运就好咯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;    上课的第一周，算是超级忙碌的一周。&lt;/p&gt;
&lt;p&gt;    上下午基本上都有课，有时候晚上也有课，十点下完课后跟随人潮涌回宿舍，有一种奇怪的感觉。&lt;/p&gt;
&lt;p&gt;    其实一个人走也会有这种感觉吧，发自内心深处的孤独。自己似乎还是不太适合喜欢别人。好像这句话自己已经</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://async0826.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>厌恶的与喜爱的</title>
    <link href="https://async0826.me/2023/02/23/%E5%8E%8C%E6%81%B6%E7%9A%84%E4%B8%8E%E5%96%9C%E7%88%B1%E7%9A%84/"/>
    <id>https://async0826.me/2023/02/23/%E5%8E%8C%E6%81%B6%E7%9A%84%E4%B8%8E%E5%96%9C%E7%88%B1%E7%9A%84/</id>
    <published>2023-02-23T15:34:40.000Z</published>
    <updated>2023-02-23T15:50:59.816Z</updated>
    
    <content type="html"><![CDATA[<p>    大概还是会觉得自己很差劲吧。</p><p>    考完试了但是考的一塌糊涂，三个月的时间足够让我把六个月前开始学习的知识统统忘记。但也确实有些迷茫。</p><p>    我的大一似乎还是没有像我自己的一开始设想的那样，竞选班干，参加各种学生社团，加入工作室……也怪自己太胆怯——在第一次失败以后便有了不好的感觉，也就不会再去尝试新的东西，更不敢像以前那样站起来说出自己的诉求与想法。</p><p>    不知道会不会是因为过度关注一些社会问题，像是最近的医保改革、以前的白纸运动，或者是更早以前的文革……探求社会现实的真相也会让我看到这个社会的阴暗面，然后便觉得天下苍生皆为如此，自己也不过是一介学生，改变不了什么。有时候好像知道了一些不太好的事情对自己就会有很大的影响——但难道就要去做什么都不知道的缩头乌龟吗？似乎只要不知道就不存在，有点古人避世的感觉了。突然想到以前高一的时候，学到了陶渊明的《归去来兮辞》，被当时还不怎么感冒的语文老师提问——如果你是当时的陶渊明，你会选择“出世”还是“入世”？只记得当时自己不过一腔热血，毅然地回答“入世”，但好像当时站着被问傻了哈哈哈。</p><p>    现在看来自己可能还会更像当陶渊明吧。如果这个世界也有可以让我安身的终南山，那即便是每日日出而作，日落而息似乎我也愿意了。但是目前看来似乎不太可能会有这样的地方。在这样的大环境下，这种行为无异于那些主流的人口中所说的“躺平”，但还能怎么办呢？</p><p>    肯定还是要去参与竞争的吧。</p><p>    寒假里读了三岛由纪夫的《丰饶之海》，尽管最后的结局不过是南柯一梦，但是《春雪》真的很打动我。可能还是他的文字吧，让我读起来觉得很清新秀雅，故事情节虽然看来可能有点俗气，但确确实实地很让我难过。还是要多多读书吧。</p><p>    虽然一直说着人生不应该被轻易定义这样的话，但是为了自己的目标，也请你放下自己的傲气，认真投入到自己该去做的事情上吧。别再去思考那些，可能你想了也不会有好结果的事情了。</p><p>    还是希望你在新的学期，保持冷静，保持思考，大胆自信一点吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;    大概还是会觉得自己很差劲吧。&lt;/p&gt;
&lt;p&gt;    考完试了但是考的一塌糊涂，三个月的时间足够让我把六个月前开始学习的知识统统忘记。但也确实有些迷茫。&lt;/p&gt;
&lt;p&gt;    我的大一似乎还是没有像我自己的一开始设想的那样，竞选班干，参加各种学生社团，加入工作室……也</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://async0826.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
