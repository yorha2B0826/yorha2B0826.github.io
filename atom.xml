<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>async&#39;s Blog</title>
  
  <subtitle>古壁生凝尘，羁魂梦中语。</subtitle>
  <link href="https://async0826.me/atom.xml" rel="self"/>
  
  <link href="https://async0826.me/"/>
  <updated>2023-04-30T13:51:05.524Z</updated>
  <id>https://async0826.me/</id>
  
  <author>
    <name>async</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DisjointSets</title>
    <link href="https://async0826.me/2023/04/30/DisjointSets/"/>
    <id>https://async0826.me/2023/04/30/DisjointSets/</id>
    <published>2023-04-30T13:28:21.000Z</published>
    <updated>2023-04-30T13:51:05.524Z</updated>
    
    <content type="html"><![CDATA[<p>非相交集是指两个没有元素相同的集合。主要的操作有连接和判断是否连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisjoinSets</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：<br><img src="/_photos/Pastedimage20230430195100.png" alt="Pasted image 20230430195100.png">此时的A B C D就是一个没有连接的状态，但是在调用了函数connect(A, B)以后：<br><img src="/_photos/Pastedimage20230430195326.png" alt="Pasted image 20230430195326.png">再去通过isConnected函数来检测，结果就会是true。</p><h2 id="快速判定"><a href="#快速判定" class="headerlink" title="快速判定"></a>快速判定</h2><p>但是要如何对其进行抽象化定义就成了一个问题，在此我们可以通过一个数组来当作案例：<br>数组的下标代表的是数字，数组中的内容相同代表着这些元素在同一个Set中：<br><img src="/_photos/Pastedimage20230430195618.png" alt="Pasted image 20230430195618.png">当我们要connect的时候，只需要把对应的数组中的值修改成相同的函数即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFindDS</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* need to iterate through the array =&gt; Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">        <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> id[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pid)&#123;</span><br><span class="line">                id[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Θ(1) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id[p] == id[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样还有一个问题，我们仅仅只能够通过这些来判断它们在同一个Set中，而无法知道他们的连接方式。</p><h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><p>为了能够明白他们的连接方式，我们可以引进Tree的概念：![[Pasted image 20230430200010.png]]<br>-1代表的是树的根，而子树元素的值相当于指向父母的指针，例如1是0的子树，那么id 1 的值就是0；通过这种方式我们可以很好地弄清他们的连接方式，同时又能够知道每个Set里面分别是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickUnionDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickUnionDS</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            parent[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> j= find(q);</span><br><span class="line">        parent[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>当我们调用connect方法时，我们总是把较小的树连接到更大的树。这样才能够保证树不会越来越深，![[Pasted image 20230430210454.png]]<br>选择2的策略比选择1的策略要更好。<br>同时我们还可以通过路径压缩的方式来减小时间复杂度：![[Pasted image 20230430210731.png]]<br>![[Pasted image 20230430210740.png]]<br>![[Pasted image 20230430210749.png]]<br>![[Pasted image 20230430210813.png]]<br>![[Pasted image 20230430210820.png]]<br>以此来控制树的深度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;非相交集是指两个没有元素相同的集合。主要的操作有连接和判断是否连接。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="cs61b" scheme="https://async0826.me/tags/cs61b/"/>
    
  </entry>
  
  <entry>
    <title>renew</title>
    <link href="https://async0826.me/2023/04/29/renew/"/>
    <id>https://async0826.me/2023/04/29/renew/</id>
    <published>2023-04-29T14:30:07.000Z</published>
    <updated>2023-04-29T14:40:42.730Z</updated>
    
    <content type="html"><![CDATA[<p>        五一。</p><p>        已经一个月没有写过博客了呢。换了新电脑以后似乎就抛开了阅读。</p><p>        开始看一些意义不大的短视频。有点接受了活在当下的想法。对未来的规划开始崩塌。</p><p>        有时候会想着，毕竟只能活一次呢。为什么不去享受更好的呢。于是消费主义与拜物主义把我销蚀。</p><p>        虽然游戏和电影一样，似乎都是我用最短的时间去感受别人的世界的一个工具。但是我的现实因为这些改变了吗。回忆起来似乎只有不值得。我痛恨我自己的消弭。</p><p>        越到高考就会越想起一年前发生的种种，以前的人有多亲密现在就有多害怕。但你的现在那位也是很搞笑呢，为什么还要假装没有在一起呢。我当然不会祝福你们，我会对你们的感情赋以最深的诅咒。</p><p>        并没有renew。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;        五一。&lt;/p&gt;
&lt;p&gt;        已经一个月没有写过博客了呢。换了新电脑以后似乎就抛开了阅读。&lt;/p&gt;
&lt;p&gt;        开始看一些意义不大的短视频。有点接受了活在当下的想法。对未来的规划开始崩塌。&lt;/p&gt;
&lt;p&gt;        有时候会想着，毕竟只</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://async0826.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>我也想有人陪我打开那扇门</title>
    <link href="https://async0826.me/2023/03/27/%E6%88%91%E4%B9%9F%E6%83%B3%E6%9C%89%E4%BA%BA%E9%99%AA%E6%88%91%E6%89%93%E5%BC%80%E9%82%A3%E6%89%87%E9%97%A8/"/>
    <id>https://async0826.me/2023/03/27/%E6%88%91%E4%B9%9F%E6%83%B3%E6%9C%89%E4%BA%BA%E9%99%AA%E6%88%91%E6%89%93%E5%BC%80%E9%82%A3%E6%89%87%E9%97%A8/</id>
    <published>2023-03-27T15:49:03.000Z</published>
    <updated>2023-03-27T16:10:59.957Z</updated>
    
    <content type="html"><![CDATA[<p>        上周什么都没有写。</p><p>        因为大部分的时间都去看了电影。即便还是和以前一样是一个人。</p><p>        最近真的很喜欢一个人的感觉。一个人去图书馆，一个人去到处走走，一个人在电影院，一个人走在大街上。不用考虑别人对自己的看法，也不用去思考下一步要往哪里走，随眼所见即是风景。</p><p>        好像还是逃不掉换季就会感冒的魔咒。说难受其实也没有那么难受，毕竟已经经验丰富了呢（笑），起初还会担心会不会是甲流或者是新冠，但目前看来大概是多虑了。</p><p>        去看了《铃芽之旅》，还是那个很熟悉的新海诚。今天在某站上刷了很多关于自然灾害的视频。就算是再科技如此发达的今天，面对自然我们还是逃不掉。但来了四川以后感觉地震似乎也就那么回事（可能还只是没有碰到灾害比较大的时候，也希望这辈子都不要遇到）。</p><p>        感冒的自己还是会跟高中一样很容易暴躁很容易生气，又突然间想起来高中的时候，还在跟她做同桌。自己因为一生病就掌控不好情绪跟她斗气，然后请假回家的那个下午小心翼翼地留下给她道歉的小纸条。</p><p>        突然间就难过起来了呢。但是那段时光已经永远都回不去了。即使你以前真的真的真的很喜欢她。但是真的已经结束了呢。</p><p>        已经无数遍这样子告诉过自己了吧。但好像也因为她，你对感情已经不再抱有任何期待。毕竟好像最后都是会分开的吧。</p><p>        上周也没有看书，毕竟真的都用来看电影了呃（笑）。虽然已经不知道下一本该看什么了。</p><p>        最近对于代码什么的不是很敏感，一心一意都在关注AI的发展以及初步的落地应用。虽然目前来说还只是一个大型的语言模型。但真的比大多数人都要更加聪明了呢。</p><p>        所以你也不能怠惰呢，起码要把学校教的东西啃明白，至于别的乱七八糟的任何事情和任何人，都见鬼去吧。。。</p><p>        所以随笔最后就是碎碎念。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;        上周什么都没有写。&lt;/p&gt;
&lt;p&gt;        因为大部分的时间都去看了电影。即便还是和以前一样是一个人。&lt;/p&gt;
&lt;p&gt;        最近真的很喜欢一个人的感觉。一个人去图书馆，一个人去到处走走，一个人在电影院，一个人走在大街上。不用考虑别人对自己的看</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://async0826.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>“dolorem exprimit quia movit amorem.”</title>
    <link href="https://async0826.me/2023/03/19/dolorem%20exprimit%20quia%20movit%20amorem/"/>
    <id>https://async0826.me/2023/03/19/dolorem%20exprimit%20quia%20movit%20amorem/</id>
    <published>2023-03-19T14:59:57.000Z</published>
    <updated>2023-03-19T15:17:16.002Z</updated>
    
    <content type="html"><![CDATA[<p>        这周听说了很多不太好的事情。不知道是巧合还是冥冥中有什么。周四的中午在推特上看到有人自杀的消息，看起来是个很受欢迎的人，正要点开他自杀前留下的信前，却因为解压密码太长而劝退——其实说来，反正与我无关。然后下午就听说上课的老师因为自己朋友的儿子自杀而烦闷。</p><p>        所以最后信息检索课变成了一节心理辅导课。其实自己的心理好像也有点问题了吧，起码自己是这么觉得的。但应该也只是暂时这样而已吧。毕竟一直都觉得，以后的人生大概还会很长吧，尽管自己并不知道会是什么样。</p><p>        这周和她聊了一下，一开始看到她的头像换成了情头，还以为对方已经过上了新的生活。但聊了之后才发现其实并没有。以为结束的事情还是没有结束。但仔细想来，明明从小学以后到现在都只见过一次，到底是为什么，对方还能把我想成这么美好的一个人。尽管我明明一次又一次地抛弃对方。但我好像确实已经没有办法再去喜欢谁了吧。生活又不是只有这样一件事。</p><p>        一个人去了都江堰。走在被商业化的所谓古城，但不过是琳琅满目的商品，体会不到有什么文化气息。都江堰景区里面也不过中规中矩。似乎任何一个山上的景区都会有的东西这里也一样会有。同质化好像有点严重了呃。</p><p>        不过自己更享受的其实是一个人吧。其实也没什么大不了的。</p><p>        这周看了《失明症漫记》，一本很残酷的小说。</p><p>        “如果你能看，就要看见。如果你能看见，就要仔细观察。”</p><p>        卡尔马克思的思想实验在这本书里面也体现得淋漓尽致了呢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;        这周听说了很多不太好的事情。不知道是巧合还是冥冥中有什么。周四的中午在推特上看到有人自杀的消息，看起来是个很受欢迎的人，正要点开他自杀前留下的信前，却因为解压密码太长而劝退——其实说来，反正与我无关。然后下午就听说上课的老师因为自己朋友的儿子自杀而烦闷。&lt;/</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://async0826.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://async0826.me/2023/03/19/%E6%A0%88/"/>
    <id>https://async0826.me/2023/03/19/%E6%A0%88/</id>
    <published>2023-03-19T09:11:36.000Z</published>
    <updated>2023-03-19T10:32:54.004Z</updated>
    
    <content type="html"><![CDATA[<p>    栈是一种先进后出的数据结构。栈是一种先进后出的数据结构，它在实际生活中有许多应用，例如：</p><ul><li><a href="https://blog.csdn.net/miachen520/article/details/127932594">子程序的调用：在跳往子程序前，会先将下个指令的地址存到栈中，直到子程序执行完后再将地址取出，以回到原来的程序中</a></li><li><a href="https://zhuanlan.zhihu.com/p/68824766">数制的转换：可以用栈来实现十进制数和其他进制数之间的转换</a></li><li><a href="https://zhuanlan.zhihu.com/p/344351768">表达式的求值：可以用栈来存储操作数和运算符，按照优先级和顺序进行计算</a></li><li><a href="https://zhuanlan.zhihu.com/p/75363294">二叉树的遍历：可以用栈来记录遍历过程中的节点信息，实现深度优先搜索</a></li></ul><p>要实现一个栈，我们可以使用一个结构来对其进行定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackElementType elem[Stack_size];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SeqStack;</span><br></pre></td></tr></table></figure><p>    这个结构中定义了一个数组，用于存储数据，还定义了一个指向栈顶的游标，以此来达到封住底部的效果。</p><p>    初始化一个栈：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SeqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    初始化一个栈的方式很简单，只需要把栈顶指针设置为-1，也就表明这是一个空栈，当然也可以使用其他具有明显意义的标志，但为了不浪费我们所定义的数组的空间，所以设置为-1较为恰当。</p><p>    把数据推入到栈中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(SeqStack *S, StackElementType elem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top &gt;= Stack_size - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stackoverflow.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;elem[++(S-&gt;top)] = elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    把数据推入栈中都需要提前检查一下栈是否已满，如果已经满了就需要退出并且提示栈已满，如果栈没有满则先把指向栈顶的指针加1，而后把数据存入栈中。</p><p>    把数据弹出栈：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">StackElementType <span class="title function_">pop</span><span class="params">(SeqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line">    --(S-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> S-&gt;elem[S-&gt;top + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    只需要把栈指针减去1，然后返回栈指针减去1的值就好，由于线性表的问题，栈指针减去1以后在物理内存上该数组还是会有残影。</p><p>    获取栈顶数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StackElementType <span class="title function_">Get_top</span><span class="params">(SeqStack *S)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;elem[S-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>    emmm其实也很简单，感觉没啥好说的，也就是把栈顶指针指向的数组的数据直接返回就好。</p><p>    下面就介绍一下两个顺序栈：</p><p>    两个顺序栈是一种特殊的顺序栈，它们共享一个存储空间，但分别从两端向中间增长或减少。这样可以节省空间，避免溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    dStackElementType elem[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top[<span class="number">2</span>];</span><br><span class="line">&#125; dStack;</span><br></pre></td></tr></table></figure><p>基本的思想很简单，就是一个栈空间分配两个栈指针，基本的操作也和普通的栈相差无几。</p><p>    初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(dStack *S)</span> &#123;</span><br><span class="line">    S-&gt;top[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    S-&gt;top[<span class="number">1</span>] = MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个栈顶指针分别指向数组的两端，以此来共享空间。<mark>需要注意的是如果两个栈指针相邻则栈满。</mark></p><p>下面介绍一下链栈：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    StackElementType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;LinkStackNode, *LinkStack;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本的操作其实和链表相一致，只不过需要自己去限定栈底。如果对用数组定义的栈比较熟练对链栈应该也能运筹帷幄。</p><p>    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;    栈是一种先进后出的数据结构。栈是一种先进后出的数据结构，它在实际生活中有许多应用，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/miachen520/article/details/127932594&quot;&gt;子程序的调用</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://async0826.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>虚妄的</title>
    <link href="https://async0826.me/2023/03/12/%E8%99%9A%E5%A6%84%E7%9A%84/"/>
    <id>https://async0826.me/2023/03/12/%E8%99%9A%E5%A6%84%E7%9A%84/</id>
    <published>2023-03-12T01:16:48.000Z</published>
    <updated>2023-03-12T01:46:14.662Z</updated>
    
    <content type="html"><![CDATA[<p>      时间过得真的很快。</p><p>      这周喜欢晚上出去跑步。</p><p>      以前会觉得跑步是一件很难受的事情，好像是从高中新校长来了之后开始的吧。当下的高中生俨然成为了官僚作秀的工具：一味压榨学生的时间来换取成绩、压榨老师的休息来换取成绩、风靡全国的“衡水”式跑操……虽然我已经算是脱离了苦海，但是有些东西还是留在那里。</p><p>      大学其实还是相比于高中好太多了，有大把可以自己操控的时间，可以去做自己想做的事情，甚至是浪费时间发呆。但高中却不允许，或许应该也有人因为高中的一切都是被安排的然后上了大学反而不知道自己应该做什么的的吧。</p><p>      跑步自己到达阈值时会有一种很奇妙的快感，然后这种快感会让我继续跑下去。虽然后半程有时候会很痛苦：第一次跑的时候还拖着抽筋的小腿继续跑下去。痛吗？很痛。但这种痛苦却能给我精神上的满足。</p><p>      <del>有点怀疑自己是不是个m了</del>，而且还会很倾慕那些比我强的多的人。从小学到现在好像一直都是这样。起码自己后面选择的人都是有过比自己强的时候的，是想要被支配吗？？？</p><p>      我在说啥呢。。。</p><p>      虽然这个博客不会被翻出来的，但其实如果哪天有人抽个风又重新打开了这个网页，估计我也就寄了呀。</p><p>      其实根本就不会有别人在意你的。</p><p>      最近总是会想到她，思来想去和高中的时候一样，要不要去找她。但是又觉得不要藕断丝连，也不要犹豫，断开了就是断开了吧。她一个人也能过得很好，我也一样。</p><p>      渴望陪伴就停滞不前是一件很蠢的事情。      </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;      时间过得真的很快。&lt;/p&gt;
&lt;p&gt;      这周喜欢晚上出去跑步。&lt;/p&gt;
&lt;p&gt;      以前会觉得跑步是一件很难受的事情，好像是从高中新校长来了之后开始的吧。当下的高中生俨然成为了官僚作秀的工具：一味压榨学生的时间来换取成绩、压榨老师的休息来换取成绩、风</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://async0826.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>单链表的一些基础操作</title>
    <link href="https://async0826.me/2023/03/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>https://async0826.me/2023/03/06/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2023-03-06T07:14:25.000Z</published>
    <updated>2023-03-12T01:12:11.397Z</updated>
    
    <content type="html"><![CDATA[<p>        初学数据结构，首先接触的就是线性表，而最基本的线性表又可以通过单链表来进行实现。</p><p>        本文的单链表使用了头节点的方式。（即第一个结点的数据域为空，指针域指向首节点）。</p><p>        询问了ChatGPT后，我所得到的关于单链表的基本操作有以下几点：</p><ol><li><p>创建一个空链表。</p></li><li><p>按值插入节点：在链表中插入一个新节点，该节点包含一个给定的值。</p></li><li><p>按位置插入节点：在链表中插入一个新节点，该节点插入到指定的位置。</p></li><li><p>删除节点：删除链表中的一个节点，可以删除链表的头部、尾部或中间的一个节点。</p></li><li><p>修改节点：修改链表中一个节点的值。</p></li><li><p>查找节点：在链表中查找一个节点，可以根据节点的值或索引来查找。</p></li><li><p>获取节点：获取链表中指定位置的节点。</p></li><li><p>获取链表长度：获取链表中节点的个数。</p></li><li><p>清空链表：清空链表中的所有节点，使链表变为空链表。</p></li><li><p>判断链表是否为空。</p></li><li><p>遍历链表：遍历链表中的所有节点，可以按照顺序输出链表中的每个节点的值。</p></li><li><p>链表反转：将链表翻转，即原来的最后一个节点变成第一个节点，原来的第一个节点变成最后一个节点。</p></li><li><p>链表排序：将链表按照指定的规则进行排序。</p></li><li><p>合并链表：将两个链表合并成一个新的链表。</p></li><li><p>判断链表是否有环。</p></li></ol><p>接下来我们通过代码具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitLinkList</span><span class="params">(Nodeptr *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    *L = (Nodeptr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        首先是初始化链表，此处笔者犯了一个很基本的错误，在传参部分最初传入了Nodeptr L而不是Nodeptr *L，可能大多数的初学者在自我尝试时也会犯这样的错误。直接传入节点的指针是无法对指针本身的值做出变化的，这是因为函数是不能改变传入的参数的值的，要想改变值，就要使用指针。初始化链表的目的是为了使用malloc函数在内存中申请一个节点的空间，并且将该节点的地址传入到头节点L中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeadCreate</span><span class="params">(Node *L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Node *new = (Nodeptr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new-&gt;data = data;</span><br><span class="line">    new-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        而后是使用头插法插入节点，在这里笔者学到的是为了保证安全性，最好每次传入一个节点的指针时都应该检查一下这个指针会不会指向NULL，以此来规避可能出现的内存访问错误。头插法的原理主要就是先申请一个空间，而后把你所需要的值传入。最后把新节点的指针域指向原头节点的指针域，而后把原头结点的指针域改为指向新节点。这样你每次新创建的值就会在头节点之后啦（不然你以为为什么会叫做头插法）。</p><p>        而尾插法与头插法其实算是比较类似的，只不过要先找到最后的那个节点。可以通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    L = L-&gt;next;</span><br></pre></td></tr></table></figure><p>这种方式来寻找，然后把新节点的指针域指向NULL，把原尾节点的指针指向新节点。</p><p>        而如果想要在任意位置插入节点进行查找，则可以通过设定具体的循环此处来进行。此处直接上代码，不再赘言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(Nodeptr L, <span class="type">int</span> locate, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr new = (Nodeptr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new-&gt;data = data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locate - <span class="number">1</span>; i++)</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    new-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        接下来是删除节点。想要删除一个节点，需要先找到被删除节点的前一个节点，将被删除节点的前一个结点指向删除结点的下一个节点，而后使用free()函数释放掉被删除节点的内存以此来达到删除的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeleteNode</span><span class="params">(Nodeptr L, <span class="type">int</span> locate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr pre;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locate; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = L-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        想要改变节点的值，这里有两种方式，第一种是通过数据域的数值来查找，第二种是通过节点的位置来查找。不过其实大同小异。要改变节点的值，首先要找到这个要被改变的节点，第一种直接通过对比数据域来查找就好，不过只能找到第一个与查找数据域相同的；而第二种通过位置来查找的则与上文提到的任意位置插入的方案一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过数据来查找</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChangeNode_num</span><span class="params">(Nodeptr L, <span class="type">int</span> change, <span class="type">int</span> before)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr P;</span><br><span class="line">    <span class="keyword">for</span> (P = L; P-&gt;data != before; P = P-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    P-&gt;data = change;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过位置来查找</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChangeNode_locate</span><span class="params">(Nodeptr L, <span class="type">int</span> locate, <span class="type">int</span> change)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locate; i++)</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    L-&gt;data = change;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>        获取节点其实就是在查找节点的基础上返回节点的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Nodeptr <span class="title function_">GetNode_num</span><span class="params">(Nodeptr L, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Nodeptr P;</span><br><span class="line">    <span class="keyword">for</span> (P = L; P-&gt;data != num; P = P-&gt;next);</span><br><span class="line">        retur</span><br><span class="line">n P;</span><br><span class="line">&#125;<span class="comment">//tips：此处的问题还是只能够返回多个相同值中第一个值的结点。</span></span><br><span class="line"></span><br><span class="line">Nodeptr <span class="title function_">GetNode_locate</span><span class="params">(Nodeptr L, <span class="type">int</span> locate)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; locate; i++)</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取结点的长度也很简单，只需要通过遍历整个链表，然后每次经过一个节点使用一个变量加上一就好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetLength</span><span class="params">(Nodeptr L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; L-&gt;next != <span class="literal">NULL</span>; i++, L = L-&gt;next)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空链表则是在遍历整个链表的基础上使用之前所写的DeleteNode()函数，但此处需要注意的是需要用一个辅助指针来进行节点的保存，否则无法达到删除整个链表的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ClearList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr P;</span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P = L-&gt;next;</span><br><span class="line">        L-&gt;next = P-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(P);</span><br><span class="line">    &#125;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断链表是否为空链表，只需要看头节点是否为空即可，若头节点的指针为空指针，说明这个链表中什么都没有。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isEmptyList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要把链表逆序，此处提出两种方案。第一种是使用三指针法：</p><p>    1.初始化三个指针pre、cur、next，pre指向NULL，cur指向第一个节点，next指向cur的下一个节点。</p><p>    2.将cur节点的next指向pre节点，即将cur的后继节点指向前驱节点，实现逆序。</p><p>    3.将pre指针向后移动一个位置，指向cur节点，cur指针向后移动一个位置，指向next节点。</p><p>    4.重复第二步和第三步，直到cur指针指向NULL，此时链表已经逆序完成。</p><p>    5.最后将链表头节点指向逆序后的第一个节点pre即可。</p><p>整个过程中，每次都将cur节点的后继节点指向前驱节点，从而实现了链表的逆序。</p><p>以下是整个过程的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ReverseList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr pre = <span class="literal">NULL</span>;</span><br><span class="line">    Nodeptr cur = L-&gt;next;</span><br><span class="line">    Nodeptr next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍另外一种方式：可以先把链表拆分为两个链表，一个只含有头节点，一个含有所有数据，然后使用头插法把含有所有数据的链表的节点逐个插入到只含有头结点的链表中去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ReverseList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的只包含头节点的链表</span></span><br><span class="line">    Nodeptr newL = (Nodeptr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newL-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原链表的数据节点一个一个地插入新链表的头节点之后</span></span><br><span class="line">    Nodeptr cur = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Nodeptr next = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点插入新链表的头节点之后</span></span><br><span class="line">        cur-&gt;next = newL-&gt;next;</span><br><span class="line">        newL-&gt;next = cur;</span><br><span class="line"></span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将原链表的头节点指向新链表的头节点</span></span><br><span class="line">    L-&gt;next = newL-&gt;next;</span><br></pre></td></tr></table></figure><p>如果想要对链表进行排序，此处可以使用冒泡排序，对每个结点中的数据进行排序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RankList</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr p = L-&gt;next;</span><br><span class="line">    Nodeptr q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;data &gt; q-&gt;data)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = p-&gt;data;</span><br><span class="line">                p-&gt;data = q-&gt;data;</span><br><span class="line">                q-&gt;data = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断链表是否有环，可以使用快慢指针的方式：快指针始终会比慢指针快，如果有环则两者就进入了一个环中，读者可以想象一下，在运动场上跑步时，不限制时间，跑的快的人总会有一次与慢的人相遇，在这里也是一样。快指针在环中不限时间，总会有与慢指针相遇的时候，所以可以把这个作为判断条件来判断链表中是否有环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">is_ring_list</span><span class="params">(Nodeptr L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Nodeptr p = L-&gt;next;</span><br><span class="line">    Nodeptr q = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p == q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是链表的一些基本操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;        初学数据结构，首先接触的就是线性表，而最基本的线性表又可以通过单链表来进行实现。&lt;/p&gt;
&lt;p&gt;        本文的单链表使用了头节点的方式。（即第一个结点的数据域为空，指针域指向首节点）。&lt;/p&gt;
&lt;p&gt;        询问了ChatGPT后，我所得到的</summary>
      
    
    
    
    
    <category term="数据结构" scheme="https://async0826.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>不愿意安于现状的</title>
    <link href="https://async0826.me/2023/03/05/%E4%B8%8D%E6%84%BF%E6%84%8F%E5%AE%89%E4%BA%8E%E7%8E%B0%E7%8A%B6%E7%9A%84/"/>
    <id>https://async0826.me/2023/03/05/%E4%B8%8D%E6%84%BF%E6%84%8F%E5%AE%89%E4%BA%8E%E7%8E%B0%E7%8A%B6%E7%9A%84/</id>
    <published>2023-03-05T06:46:11.000Z</published>
    <updated>2023-03-05T07:04:45.708Z</updated>
    
    <content type="html"><![CDATA[<p>    上课的第一周，算是超级忙碌的一周。</p><p>    上下午基本上都有课，有时候晚上也有课，十点下完课后跟随人潮涌回宿舍，有一种奇怪的感觉。</p><p>    其实一个人走也会有这种感觉吧，发自内心深处的孤独。自己似乎还是不太适合喜欢别人。好像这句话自己已经对自己说了很多遍了。倒不是喜欢别人别人会怎么样，只是自己太容易患得患失，而且还有一点点讨好型人格在身上的。</p><p>    所以还是好好一个人走吧，就算是一个人出去看看成都。</p><p>    突然想到上个学期回家前两天，同一个宿舍的同学在十点过后拿起书包走出宿舍门，我惶恐地问他：这个点你出去要干嘛。但他只是说：我想去看看成都。我也想去看看成都。疫情以来确实失去了太多。高三过后犹如囚笼的暑假，并没有如自己高考前所想的那样美好：能够与同学一起去一场毕业旅行，和喜欢的人一起走向自己喜欢的大学。</p><p>    刚刚起床刷朋友圈，看到高中的一个在华东师范大学的同学去了上海交大，有点难受的吧。毕竟算是我喜欢了三年的大学。结果自己也没有如意，高考的那两天算是前十九年里过的最失败最恍惚的两天了吧。但怎么可能会有完美的一生。今后也还是会有很多不如意的吧。但也只能在当下尽量别让以后的自己像现在这样了。</p><p>    还没到时间怀念从前。</p><p>    虽然这次考试确实真的考得很烂，但才六分之一呢。凭什么因为一个学期的落后就否定掉自己。也希望不是在自我洗脑吧。</p><p>    也别再想，如果当初自己选择的不是抛弃，而是和她一起努力，结果会不会不一样了吧。毕竟好像你已经不想再花这样的时间与精力去重新认识一个人了。可能她也不想吧，那个我十八岁偷偷送我生日蛋糕的女孩。</p><p>    大概灵魂深处还是渴望得到陪伴，得到理解吧。但好像永远都不会有这样的异性了。</p><p>    所以还是把精力更多地花在自己身上吧。不要安于现状，有自己的秘密计划，努力争取自己的幸运就好咯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;    上课的第一周，算是超级忙碌的一周。&lt;/p&gt;
&lt;p&gt;    上下午基本上都有课，有时候晚上也有课，十点下完课后跟随人潮涌回宿舍，有一种奇怪的感觉。&lt;/p&gt;
&lt;p&gt;    其实一个人走也会有这种感觉吧，发自内心深处的孤独。自己似乎还是不太适合喜欢别人。好像这句话自己已经</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://async0826.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>厌恶的与喜爱的</title>
    <link href="https://async0826.me/2023/02/23/%E5%8E%8C%E6%81%B6%E7%9A%84%E4%B8%8E%E5%96%9C%E7%88%B1%E7%9A%84/"/>
    <id>https://async0826.me/2023/02/23/%E5%8E%8C%E6%81%B6%E7%9A%84%E4%B8%8E%E5%96%9C%E7%88%B1%E7%9A%84/</id>
    <published>2023-02-23T15:34:40.000Z</published>
    <updated>2023-02-23T15:50:59.816Z</updated>
    
    <content type="html"><![CDATA[<p>    大概还是会觉得自己很差劲吧。</p><p>    考完试了但是考的一塌糊涂，三个月的时间足够让我把六个月前开始学习的知识统统忘记。但也确实有些迷茫。</p><p>    我的大一似乎还是没有像我自己的一开始设想的那样，竞选班干，参加各种学生社团，加入工作室……也怪自己太胆怯——在第一次失败以后便有了不好的感觉，也就不会再去尝试新的东西，更不敢像以前那样站起来说出自己的诉求与想法。</p><p>    不知道会不会是因为过度关注一些社会问题，像是最近的医保改革、以前的白纸运动，或者是更早以前的文革……探求社会现实的真相也会让我看到这个社会的阴暗面，然后便觉得天下苍生皆为如此，自己也不过是一介学生，改变不了什么。有时候好像知道了一些不太好的事情对自己就会有很大的影响——但难道就要去做什么都不知道的缩头乌龟吗？似乎只要不知道就不存在，有点古人避世的感觉了。突然想到以前高一的时候，学到了陶渊明的《归去来兮辞》，被当时还不怎么感冒的语文老师提问——如果你是当时的陶渊明，你会选择“出世”还是“入世”？只记得当时自己不过一腔热血，毅然地回答“入世”，但好像当时站着被问傻了哈哈哈。</p><p>    现在看来自己可能还会更像当陶渊明吧。如果这个世界也有可以让我安身的终南山，那即便是每日日出而作，日落而息似乎我也愿意了。但是目前看来似乎不太可能会有这样的地方。在这样的大环境下，这种行为无异于那些主流的人口中所说的“躺平”，但还能怎么办呢？</p><p>    肯定还是要去参与竞争的吧。</p><p>    寒假里读了三岛由纪夫的《丰饶之海》，尽管最后的结局不过是南柯一梦，但是《春雪》真的很打动我。可能还是他的文字吧，让我读起来觉得很清新秀雅，故事情节虽然看来可能有点俗气，但确确实实地很让我难过。还是要多多读书吧。</p><p>    虽然一直说着人生不应该被轻易定义这样的话，但是为了自己的目标，也请你放下自己的傲气，认真投入到自己该去做的事情上吧。别再去思考那些，可能你想了也不会有好结果的事情了。</p><p>    还是希望你在新的学期，保持冷静，保持思考，大胆自信一点吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;    大概还是会觉得自己很差劲吧。&lt;/p&gt;
&lt;p&gt;    考完试了但是考的一塌糊涂，三个月的时间足够让我把六个月前开始学习的知识统统忘记。但也确实有些迷茫。&lt;/p&gt;
&lt;p&gt;    我的大一似乎还是没有像我自己的一开始设想的那样，竞选班干，参加各种学生社团，加入工作室……也</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://async0826.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
